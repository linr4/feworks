# 闭包（closure）

1. 什么是闭包？

   是一种特殊形式的函数。

2. 如何生成一个闭包？

   当一个内部函数引用了外部函数的数据（变量、函数）时，内部函数既是闭包；

   即：满足两个条件 1) 函数嵌套；2) 内部函数引用外部函数的数据。

3. 闭包特点：

   只要闭包仍在使用外部函数的数据，该数据就不会被释放，从而延长了该数据的生命周期。

   因此，闭包不再使用时，需要手动将其置为 null 以释放被它 hold 住的数据。

4. 举例说明：

   无闭包的情况：

```js
function fn1() {
    var i = 1;	// 局部变量
}				// 函数代码结束，变量 i 自动释放
console.log(i); // undefined
```

​	 有闭包的情况：

```js
function fn1() {
    var i = 1;
    function fn2() {   // 满足闭包两个条件：1) 函数嵌套 2) 调用外部函数数据，因此fn2为闭包；
        console.log(i);
    }
}
```

```js
function fn1() {
    var i = 1;
    function fn2() {
        console.log(i);
    }
}	  // 由于如下闭包的调用，i 在此函数结束的位置之后仍没有释放；

let fn = fn1();
fn(); // 1 仍能读到 i 的值；
```





# 循环索引的同步

* 默认情况下，代码从上到下、顺序执行，

* `var` 定义的变量只要不在函数中，就都是全局变量；



##### 不能同步循环索引的情况：

```js
for (var i = 0; i < 3; i++) {
    // nothing done
}
console.log(i);	// 3  // 因为 i 在 for 循环中用 var 定义，是全局变量

/***************************/

for (var i = 0; i < 3; i++) {
    function fn() {
		console.log(i);   
    }
}
fn(); // 3	// 无法同步显示循环中的值，因为 fn()执行时，for循环已经完成
```



##### 可以同步循环索引的情况：	让 `i` 输出每次循环中的值，三种写法：

```js
/* 说明：
1. 每次循环都会定义一次 fn() 函数，因为函数同名，所有本次定义覆盖了上一次定义；
2. 每次定义都会产生一个当次独有的作用域、保留了当次 i 的值；
3. 后两种为 IIFE，实际上是第一种写法的简写 ———— 定义完后立即执行，作用一样；
4. 函数 fn 中并未定义 i，因此是引用了外部定义的 i；console.log() 本质上也是函数，如此，满足了闭包形成的两个条件，在这里也是闭包。
*/

for (var i = 0; i < 3; i++) {
    function fn() {
        console.log(i); // 0 1 2
    }
    fn();	// 显式执行该函数；
}
/******************************/
for (var i = 0; i < 3; i++) {
    (function fn() {
        console.log(i); // 0 1 2
    })();
}
/******************************/
for (var i = 0; i < 3; i++) {
    (function fn(idx) {
        console.log(idx); // 0 1 2
    })(i);
}
```



##### 块级作用域产生的闭包

```js
for (let i = 0; i < 3; i++) {	// {} 块级作用域
    function test() {
        console.log(i); // 在函数中用到了外部块级作用域的变量
    }
}
test(); // 2	// 最后一次满足条件的循环中，i的值为2
```

