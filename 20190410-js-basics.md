# JavaScript Basics

### JavaScript 的 3 个组成部分

* ECMAScript：代码部分
* DOM：操作网页标签的 API
* BOM：操作浏览器的 API



### JS 的输出

* 三种输出方式：
  * 弹窗 `alert()` 、文档 `document.write() `、控制台 `console.log()` ；
* 与 `alert()` 相似的函数：
  * `comfirm()`，比 alert() 多一个 “取消” 按钮
  * `prompt()`，多一个输入框
  * 注意点：输出内容为字符时，需要加上引号
* console 输出有 3 个方法： `.log()`、 .`warn()`、 `.error()`；



### 变量

* 变量定义之后如果没有初始化，其值为 undefined；

* 多个变量同时定义和赋值： 

  * `var x, y, z; x = y = z = 0;` 
  * `var x = 0, y = 1, z = 2;`
  * `let [x, y, z] = [0, 0, 0];`

* 变量可以用 `var` 重复定义，后定义的会覆盖以前定义的；

* 使用 `var` 定义变量时（ES6 之前），变量可以先使用再定义，由于预解析的缘故：

  ```js
  console.log(num);	// undefined
  var num = 888;	// 使用在前、定义在后
  /*
  	上面代码预解析之后的结果：
  		var num;	// 预解析后 JS 会把变量、函数的定义提到最前
  		console.log(num);
  		num = 888;
  		
  	在代码运行时，其实变量已经定义过了，所以值为 undefined；
  */
  ```

* ES6 开始，使用 `let` 定义变量时，不允许先使用再定义，同一代码块内也不能重复定义；

  ```js
  let x;	// undefined
  let x;	// Uncaught SyntaxError: Identifier 'x' has already been declared
  console.log(y);	// Uncaught ReferenceError: y is not defined
  ```

  

### 数据类型转换

* 其它基本类型转 String 类型

  * 方法一：**val.toString()** ，会改变调用对象的值，因此常量及 undefined/null 不能使用此方法；

    * **Number**: `let value = 123; value.toString();`

    * **Boolean**: `let value = true; value.toString();`

    * 注意： 

      * `123.toString()` 会报错，**常量**不能转换类型；

      * `let val = undefined; val.toString();` 会报错，**undifined** 不能转换类型；

      * `let val = null; val.toString();` 会报错，**null** 不能转换类型；

        

  * 方法二：**String(常量or变量)** ，不会改变传入的常量或变量的值，因此也可用于常量/undefined/null；

    ```js
    let val = undefined;
    let str = String(val);
    console.log(str);	// undefined
    console.log(typeof str);	// string
    
    let val = null;
    console.log(typeof val);	// object
    let str = String(val);
    console.log(typeof str);	// string
    
    let val1 = undefined;
    let val2 = null;
    str1 = string(val1);	// undefined
    str2 = string(val2);	// null
    ```

    

  * 方法三：**常量or变量 + 空字符串 “”**，本质上是调用了 `String()` 函数做了转换处理；

    

* 其它基本类型转 Number 类型

  * 方法一：用 `Number(param)` 函数；

    * 参数为纯数字则正常转换；

    * 参数若为空串（如：“”、“    ”），结果为 0；

    * 布尔类型，true => 1、false => 0；

    * null 也转为 0；

    * 若不是纯数字（如："12px"），则结果为 NaN；

    * undefined 也转为 NaN；

      

  * 方法二：对字符串做加减运算（+ / -）

    * 减号会改变正负性，通常用加号；

    * 底层也是调用了 `Number()` 函数；

    ```js
    let str = "123";
    let num = +str;	// 123, typeof --> Number
    let num = -str;	// -123, typof --> Number
    
    let num = +"456";	// 456 Number
    let num = +"";		// 0
    let num = +"  ";	// 0
    let num = +"12px";	// NaN
    
    let flag = true;
    let num = +flag;	// 1
    let flag = false;
    let num = +flag;	// 0
    
    let value = null;
    let num = +value;	// 0
    
    let value = undefined;
    let num = +value;	// NaN
    ```

    

    * 方法三：`parseInt()` 与 `parseFloat()` 函数，
      * 好处：可以解析和转换出字符串中的数字部分，如：`parseInt("12px") // 12`；
      * 从左到右提取，遇到非数字后停止；
      * 停止后仍未遇到数字，则返回 NaN；
      * 不管传入何种类型的参数数据，都会当字符串处理，如：`parseInt(true) // NaN` ；

    

* 其它基本类型转 Boolean 类型
  * 用 `Boolean(param)` 函数；param 为常量或变量；
    * 字符串（包括**空格**）转为 `true`，空串 `“”` 转为 `false`；
    * 非零数值（包括负数）转为` true`，只有 `0`（包括正负零）才转为 `false`；
    * `typeof NaN` 为 `Number`，转布尔类型后为 `false`；
    * `undefined` 和 `null` 转为 `false`；
  * 总结：只有 `"", 0, NaN, undefined, null` 转为 `false`，其它为 `true`；



### 运算符

* 按功能分类

  * 算术运算符：`+, -, *, /, %`

    * 非数值类型的数据做**加减法**运算前，自动先转成数值：

      ```js
      let x = 1 + true; // true 会转成 1，结果 x = 2
      let x = 1 - true; // 0
      let y = 1 + null; // null 转成 0
      ```

    * 任何数值和 `NaN` 做**加减法**运算，结果都为 `NaN`；

      ```js
      let x = 1 + NaN; // 结果为 NaN
      let x = 1 - NaN;  // 仍为 NaN
      let y = true + NaN; // 结果为 NaN
      ```

    * 任何数据和字符串相加，自动先转成字符串：

      ```js
      let x = 1 + "123"; // 结果为字符串拼接 "1123"
      let y = NaN + "123"; // "NaN123"
      ```

    * 任何数据和字符串相减（以及乘除），若能转数值则自动先转为数值，无法转则结果为 `NaN`：

      ```js
      1 - true; //  1 - 1 === 0
      1 - "123"; // -122
      "a" - 1; // NaN
      ```

    * 取余运算， `m % n = remainder`

      ```js
      10 % 3; // 1 - 如果 m > n，正常取余
      3 % 10; // 3 - 如果 m < n，结果为 m
      10 % 0; // NaN - 如果 n = 0，结果为 NaN
      
      // 结果的正负，取决于 m，与 n 的正负无关：
      -10 % 3; // -1
      10 % -3; // 1
      ```

      

  * 位运算符：

    

  * 关系运算符：`>, <, >=, <=, ==, !==, ===, !=== ` 

    * 结果只能是 true / false；

    * 非数值类型会先转为数值再做运算：

       ```js
        1 > true; // false
        1 > null; // true
        1 > "0"; // true
        1 > "10"; // false
       ```

    * 任何数据和 NaN 比较结果均为 false；

    * undefined 转为数值后为 NaN，与其比较结果也是 false；

      ```js
      666 > NaN;	// false
      666 < NaN;	// false
      666 > undefined;	// 等价于 666 > NaN，结果 false
      ```

    * 字符串之间做比计较，不会转为数值，而是从左到右逐个比较字符的 unicode，直到条件不满足为止；

      ```js
      "a" > "b"; // 等价于 0061 > 0062 == false
      "abc" > "abd" // c 的 unicode 小于 d，结果 false
      ```

    * 特殊情况：

      ```js
      null == 0; // false
      undefined == 0; // false，undefined 转数值后为 NaN
      null == undefined; // true，null 由 undefined 衍生而来
      NaN == NaN; // false，判断是否 NaN 用全局方法 isNaN(num);
      ```

    * `==, !=` 与 `===, !==` 的区别：

      * `==` 只判断**取值**是否相等；
      * `===` 同时判断**取值**以及**数据类型**是否相等；

      ```js
      123 != "123"; // false
      123 !== "123"; // true
      ```

    * 关系运算为左结合性（从左至右运算），赋值运算则是右结合性（如 `x = y = 1;`）

      ```js
      x = 10 > 5 > 3; // false ==> 运算过程：true > 3 ==> 1 > 3 ==> false
      ```

    * 优先级：`>, <, >=, <=` 优先于 `==, !=, ===, !==`

      ```js
      10 == 10 > 0; // false；先做了大小比较 (10 > 0 = true = 1)、再做相等比较 ( 10 == 1)
      ```

      

  * 逻辑运算符：`&&, ||, !`

    * 左结合性；

    * 优先级：逻辑非 `!` > 逻辑与 `&&` > 逻辑或 `||`

    * 非布尔类型的逻辑运算，会先转为布尔类型再运算；

    * 非布尔类型的逻辑与 `&&` 运算，返回值不是 true 或 false，而是：

      ```js
      // 格式：A && B;	  （A 和 B 均不是布尔类型）
      // 若 A 不成立 (false)，则返回 A
      0 && 123; 	// 0
      null && 123;// null
      
      // 若 A 成立 (true)，无论 B 是否成立、均返回 B
      1 && 123;	// 1
      1 && null;	// null
      ```

    * 非布尔类型的逻辑或 `||` 运算，返回值不是 true 或 false，而是与逻辑与`||`运算相反：

      ```js
      // 格式：A || B;	  （A 和 B 均不是布尔类型）
      // 若 A 成立 (true)，则返回 A
      666 || 123; // 666
      
      // 若 A 不成立 (true)，无论 B 是否成立、均返回 B
      0 || 123;	// 123
      0 || null;// null
      ```

    * 逻辑与 和 逻辑或的短路现象：

      ```js
      let x = (10 > 20) && (++num > 0); // 其中的 ++num 不会运行；
      let y = (10 < 20) && (++num > 0); // 其中的 ++num 不会运行；
      ```

  * 逗号运算符：

    * 常用于简化代码；
    * 左结合性；
    * 所有运算符中优先级最低；
    * 同其它运算符一样有运算结果，结果为最后一个表达式的运算结果；

    ```js
    let a, b;	// 利用逗号运算符，同时定义多个变量；
    a = 10, b = 5;	// 一次性给多个变量赋值；
    let x = ((1 + 1), (2 + 2), (3 + 3));	// 结果为 6
    ```

    

  * 三目运算符（条件运算符）：`condition_statement ? result_A : result_B`

  * 自增、自减运算符：

    ```js
    let a = 5;
    let x = a++ + a++; // 11 取出值后自增，第一个 a = 5，第二个 a = 6
    
    let b = 5;
    let y = ++b + ++b; // 13 自增之后取值，第一个 b = 6，第二个 b = 7
    ```

    

* 按操作数分类

  * 单目运算：`i++, i--, ++i, --i `
  * 双目运算：`a + b`
  * 三目运算：`a > b ? 1 : 2`



* 表达式：用运算符连接在一起、有意义有结果的语句；





### 流程控制语句 & Some Tips:

* 交换两个变量的值除了借用临时变量之外，还可以如下：

```js
let a = 6, 
    b = 7;
a = a + b;	// a == 13
b = a - b;	// b == 13 - 7 == 6
a = a - b;	// a == 13 - 6 == 7
```

* `if` 判断条件是否相等时（`==` 与 `===`） 把常量写在前面，可减少人为疏忽的可能：

```js
let num = 0;
if (5 == num) {	// 若写成 (num = 5) 变成赋值语句，程序不会报错，增加排查难度；而 (5 = num) 会报错；
    console.log('num is equal to 5')
}
```

* 分号 `;` 是空语句，花括号`{}` 已明确代码块范围， 右花括号 `}` 之后可以不加分号 `;`
* `prompt()` 的返回值是字符串，即使输入的是数字；

* 关于 `switch` 判断语句

  * `switch` 和`case` 的条件可以是常量、变量以及表达式：

  ```js
  switch(表达式S) {
      case 表达式1:	// 之前没有意识到 case 也可以是表达式，常见用常量、即表达式S 的结果；
          语句1;
          break;
      case 表达式2:	// case 的表达式 将与 switch 的表达式s 比较；
          语句2;
          break;
      ... ...
      default: 
      	语句n;
          break;
  }
  /*********************************************/
  switch ((new Date().getDay())) {
    case Number(false):   // if it's 0
      console.log('today is sunday');
      break;    
  }
  /*********************************************/
  let x = 123;
  // 此处三个 switch / case 同样效果；
  switch (x) {case x: console.log('condition of case is a variable')};	
  switch (123) {case 123: console.log('condition of case is a const')};	
  switch (122 + 1) {case 122 + 1: console.log('condition of case is an statement')};	
  
  ```

  * `case` 判断是 **全等** `===`、而非 **值等** `==` ；

  * `break` 为立即结束整个 `switch` 语句；若有一个 `case`  或 `default` 成立，则其它 `case` 条件失效，若无 `break` 则剩下的 `case` 语句都会执行；

  * `default` 不必非得放在最后，放任意位置都会等到所有 `case` 都不满足之后再执行； 

    ```js
    // 综合应用案例：分数评级
    
    let str = prompt('please input your score:')
    let score = parseInt(+str / 10);	// 除以 10 取整，则 90~99 都为 9，简化判断；
    
    switch (score) {
        case 10:	// 没有 break 会继续执行下一个 case；
        case 9:
            alert("A");
            break;
        case 8:
            alert("B");
            break;
        case 7:
            alert("C");
            break;
        case 6:
            alert("D");
            break;
        case 5:
        case 4:	// 没有 break 会继续执行下一个 case；
        case 3:
        case 2:
        case 1:
        case 0:
            alert("E");
            break;
    }
    ```

* `if` 与 `switch` 用哪个？

  * 判断区间值，用 `if`
  * 判断固定值，用 `switch`
  * 原则：能用 `if` 就尽量用 `if`



* 关于变量作用域：
  * 无论是 `var` 或是 `let` 定义的全局变量，都可在同一个 html 文件的不同 `<script>` 标签之间直接引用；
  * `用 var` 定义的变量没有作用域，都可全局引用，即使放在大括号 `{var x = 1;}` 中也一样；
  * 用 `let` 定义的变量才有局部作用域，放在代码块中 `{let x = 1;}` 之后就无法跨作用域访问；



* `for` 循环表达式

  * 格式 ： `for ([初始化表达式]; [条件表达式]; [循环后增量表达式]) {循环体}`，三个表达式均可省略；

  * 执行流程：

    1. 执行初始化表达式，**只执行一次！** 可以写在 `for` 表达式之外（上面），与 `while` 一样的写法；

    2. 判断条件表达式，若为真，执行循环体；

    3. 执行增量表达式；
    4. 重复 2、3，直至条件表达式 false；



* `for` 与 `while` 用哪个？

  * `for` 比 `while` 灵活且可以替代 `while` 的功能，所以：

    > Use `for` loop rather than `while` loop whenever possible!



* `break`  & `continue`

  * `break` 除了用于结束 `switch...case` ，也用于跳出 `for` / `while` 循环体；

  * `continue` 用于结束本次循环（`continue`之后的代码不执行）、进入下一次循环；

    

* 循环嵌套的规律：外行内列 / ERIC

  ```js
  for (let i = 0; i < 3; i++) {		// 外循环控制行数 External loop controls Rows
      for (let j = 0; j < 4; j++) {	// 内循环控制列数 Internal loop controls Columns
          document.write('*')
      }
  }
  ```



* 循环练习案例：

  ```js
  *****
  ****
  ***
  **
  *
      
  for (let i = 0; i < 5; i++) {
    for (let j = i; j < 5; j++) {	  // 逐行递减，让内循环初始化表达式 j = 外循环初始化条件变量 i
      document.write('*')
    }
    document.write('<br>')
  }
  
  ////////////////////////////////////////////////////////////
      
  *
  **
  ***
  ****
  *****
  
  for (let i = 0; i < 5; i++) {
    for (let j = 0; j <= i; j++) {  // 逐行递增，让内循环条件表达式 j <= 外循环初始化变量 i
      document.write('*')
    }
    document.write('<br>')
  }
  
  ////////////////////////////////////////////////////////////
  
  /*
  1
  12
  123
  1234
  12345
  */
  
  for (let i = 1; i <= 5; i++) {
    for (let j = 1; j <= i; j++) {
      document.write(j)
    }
    document.write('<br>')
  }
  
  ////////////////////////////////////////////////////////////
  
  /*
  1
  22
  333
  4444
  55555
  */
  
  for (let i = 1; i <= 5; i++) {
    for (let j = 1; j <= i; j++) {
      document.write(i)
    }
    document.write('<br>')
  }
  
  ////////////////////////////////////////////////////////////
  mathematics multiplication table
  
  1x1=1 
  1x2=2 2x2=4 
  1x3=3 2x3=6 3x3=9 
  1x4=4 2x4=8 3x4=12 4x4=16 
  1x5=5 2x5=10 3x5=15 4x5=20 5x5=25 
  1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36 
  1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49 
  1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64 
  1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81 
  
  
  for (let i = 1; i <= 9; i++) {
    for (let j = 1; j <= i; j++) {
      document.write(`${j} x ${i} = ${i*j} `)
    }
    document.write('<br>')
  }
  
  ////////////////////////////////////////////////////////////
  
  -******
  --***
  ---*
      
  let asteriskAmount = 6;
  
  for (let rows = 1; rows <= 3; rows++) {
   for (let dashes = 1; dashes <= rows; dashes++) {
      document.write('-');
   }
    asteriskAmount = asteriskAmount / rows;
    for (let asterisk = 1; asterisk <= asteriskAmount; asterisk++) {
      document.write('*');
    }
    document.write('<br>')
  }
  ```

  



### 数组 Array

* Basics
  * 非基本数据类型，而是**引用数据类型**（对象类型）

  * 创建方法：
    ```js
    // 通过构造函数 Array() 创建
    let arr = new Array(2);  // 创建指定大小的数组
    let arr = new Array();	 // 创建空数组
    let arr = new Array(data1, data2, data3, ...);  // 创建带数据的数组
                        
    // 通过字面量创建（是通过构造函数创建的简写方式，实际开发中更常用这种方式）
    let arr = [];			 // 创建空数组
    let arr = ['a', 2, true, null, 'whatever'];		// 创建带数据的数组
    ```

* 知识点：

  * 引用的索引位置若**未存储数据**，则为 `undefined`；其它语言的数组存的是垃圾数据或 0；

  * 访问**不存在的索引**不会报错，而是返回 `undefined`；其它语言会报错或返回脏数据；

  * 数组存储空间不够时会**自动扩容**；其它语言的数组大小固定；

    ```js
    let arr = new Array(2);
    arr[0] = 'Joe';
    arr[1] = 'Don';
    arr[2] = 'Tom';
    console.log(arr);	// arr.length == 3, includes three members
    ```

  * 每个成员的数据类型可以不同；其它语言单个数组只能存储相同类型的数据；

  * JS 数组分配的内存地址不一定是连续的，性能有影响，现代浏览器做了相应优化：

    * 若存储相同类型的数据，尽量分配连续空间；

    * 若存储不同类型的数据，则不会分配连续空间；

      

* 解构赋值：

  ```js
  let arr = [1, 3, 5];
  let [a, b, c] = arr; // or 
  let [a, b, c] = [1, 3, 5];
  ```

  * 左右两边的格式需一样，才能完全解构和赋值；

    ```js
    let [a, b, [c, d]] = [1, 2, [3, 4]]; // a = 1, b = 2, c = 3, d = 4;
    ```

  * 左右两边的个数可以不一样；

    * 右边不够，左边就赋值为 undefined；
    * 左边可以指定默认值，但默认值会被右边覆盖；
    * 也可使用扩展运算符 `...` 打包右边多出来的作为子数组赋值给左边变量，只能用在最后一个变量；

    ```js
    let [a, b] = [1, 3, 5]	// a = 1, b = 3;
    let [a, b, c] = [1, 3]  // a = 1, b = 3, c = undefined;    右边不够，左边就 undefined
    let [a, b = 6, c = 8] = [1]  	   // a = 1, b = 6, c = 8; 指定默认值
    let [a, b = 6, c = 8] = [1, 2, 3]  // a = 1, b = 2, c = 3; 默认值被覆盖
    let [a, b, ...c] = [1, 2, 3, 4, 5] // a = 1, b = 2, c = [3, 4, 5]
    ```

    