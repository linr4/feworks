<script>

let arr = [11,22,33,44,55];

console.log(arr);  // [11, 22, 33, 44, 55]

/*
// 方式一：不可行
for (let i = 0; i < arr.length; i++) {
  arr.splice(i, 1);  // 从索引 i 开始，删除一个元素
}
console.log(arr);  // [22, 44]
// 并没有达到预期结果，原因是 splice() 每次操作之后会改变数组长度，影响到循环次数
*/

/*
// 方式二：不可行
let len = arr.length; // 让循环次数不因数组长度变化而改变
for (let i = 0; i < len; i++ ) {
  arr.splice(i, 1);
}
console.log(arr);  // [22, 44]
*/

/*  仍然没有达到预期结果，原因是 splice() 每次删除一个元素之后，后面的元素会前移、索引值会变化
i   arr.splice(i, 1)
0   [22, 33, 44, 55]  // 删除索引 0 的元素 11，之后元素前移，索引 1 的元素变为 33
1   [22, 44, 55]      // 删除索引 1 的元素 33，之后元素前移，索引 2 的元素变为 55
2   [22, 44]          // 删除索引 2 的元素 55，之后元素前移，索引 1 的元素变为 44 且为最后一个元素
3   [22, 44]          // 此时不存在索引为 3 的元素了
*/

/*
// 方式三：可行（用 splice 从后往前删除元素）
for (let i = arr.length - 1; i >= 0; i--) {
  arr.splice(i, 1); // 始终删除的都是最后一个元素，不受数组长度变化和元素前移的影响
}
console.log(arr); // [], this time it works.
*/

// 方式四：可行（用 delete 关键字）
for (let i = 0; i < arr.length; i++) {
  delete arr[i];
}
console.log(arr); // [empty × 5]
// it works but slightly different from splice(),
// the elements were cleared but array slots are still there.
// splice() removes array slots as well.


</script>